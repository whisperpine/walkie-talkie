# Walkie Talkie

Open this web page, and starts to talk with others: <https://wt.yusong.me/>\
You can also open multiple tabs on the browser to imitate a group of users.

## Table of Contents

<!--toc:start-->
- [Walkie Talkie](#walkie-talkie)
  - [Table of Contents](#table-of-contents)
  - [Deployment](#deployment)
    - [Simplified Deployment](#simplified-deployment)
    - [High availability Deployment](#high-availability-deployment)
  - [OpenAPI](#openapi)
  - [Dev Environment](#dev-environment)
  - [Dev Exeprience](#dev-exeprience)
  - [Roadmap to Production](#roadmap-to-production)
<!--toc:end-->

## Deployment

### Simplified Deployment

This approach is currently used in a pintch (see [./prod.compose.yaml](./prod.compose.yaml)).

```mermaid
flowchart LR
  subgraph frontend
    webapp_a("wt-webapp A")
    webapp_b("wt-webapp B")
    webapp_c("wt-webapp ...")
  end


  cfgate("cloudflare<br>edge")

  webapp_a --- cfgate
  webapp_b --- cfgate
  webapp_c --- cfgate

  cfgate ---|tunnel| cfd

  subgraph services
    cfd("cloudflared")
    wc("wt-websocket<br>(for streaming)")
    restapi("wt-rest-api<br>(server impl)")
    db("postgres")
    cfd --- wc
    cfd --- restapi
    restapi -.- db
    wc -.- db
  end


  %% db("database")
  %% services -.- db
  style db stroke-dasharray: 5
```

### High availability Deployment

This approach should be used in production.

```mermaid
flowchart LR
  subgraph frontend
    webapp_a("wt-webapp A")
    webapp_b("wt-webapp B")
    webapp_c("wt-webapp ...")
  end

  webapp_a --- gateway
  webapp_b --- gateway
  webapp_c --- gateway

  subgraph kubernetes
    gateway["ingress /<br>gateway api"]
    wc["wt-websocket<br>(streaming service)"]
    restapi("wt-rest-api<br>(REST service)")
    wc_pod_a("pod 1")
    wc_pod_b("pod ...")
    restapi_pod_a("pod 1")
    restapi_pod_b("pod ...")

    gateway --- wc
    gateway --- restapi

    wc --- wc_pod_a
    wc --- wc_pod_b

    restapi --- restapi_pod_a
    restapi --- restapi_pod_b
  end

  wc_pod_a --- db
  wc_pod_b --- db
  restapi_pod_a --- db
  restapi_pod_b --- db

  subgraph cloud managed
    db("postgres")
  end
```

## OpenAPI

OpenAPI specifications under [./openapi](./openapi/)
work as the *Single Source of Truth*:

- Design and write [OpenAPI Specifications](https://www.openapis.org/) (OAS) files.
- Generate server stubs (see [./wt-rest-stubs](./wt-rest-stubs)) by [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator).
- Generate client sdk (see [./wt-webapp-sdk](./wt-webapp-sdk)) by [openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator).
- Lint OAS files by [redocly](https://github.com/Redocly/redocly-cli)
  and generated HTML which is deploy on [GitHub Pages](https://whisperpine.github.io/walkie-talkie/).
- Run contract tests by [Arazzo](https://www.openapis.org/arazzo-specification),
  generated by [redocly](https://github.com/Redocly/redocly-cli)
  according to OpenAPI Specifications.

```mermaid
flowchart LR
  oas(openapi<br>specifications):::red_stroke
  stubs("wt-rest-stubs<br>(server stubs)")
  csdk("wt-webapp-sdk<br>(in typescript)")
  arazzo("arazzo configurations")
  webapp("wt-webapp<br>(client app)")
  restapi("wt-rest-api<br>(server impl)")

  oas -->|openapi-generator| stubs
  stubs --> restapi
  oas -->|openapi-generator| csdk
  csdk --> webapp
  webapp -.-|requests| restapi
  oas -->|redocly| arazzo
  arazzo -.-|contract tests| restapi

  classDef red_stroke stroke: #f66
```

## Dev Environment

Dev environment is managed by Nix Flakes.
If you're not using nix, it's required to manually install tools listed in the
`packages` section of [flake.nix](./flake.nix).
Otherwise you can just run the following command to enter dev environment:

```sh
# `nix develop` needs to be run every time you `cd` in.
cd THIS_REPO && nix develop
```

[nix-direnv](https://github.com/nix-community/nix-direnv)
is highly recommended.
It automatically runs `nix develop` every
time you `cd` to the project.

```sh
# `dirnev allow` needs to be run only once.
# After that, when you `cd` in, nix dev env will be automatically loaded.
cd THIS_REPO && dirnev allow
```

## Dev Exeprience

Run `just -l` to see commonly used commands in this repo:

```txt
Available recipes:
    arazzo    # run OpenAPI contract tests by Arazzo
    build-api # build the docker image for wt-rest-api
    build-wt  # build the docker image for wt-websocket
    doc       # generate API documentation as an HTML file
    front     # run frontend wt-webapp in debug mode
    gen-axum  # generate server stubs with rust-axum generator
    gen-ts    # generate typescript client sdk
    lint      # lint OpenAPI Specifications
    preview   # build frontend wt-webapp and preview
    rest-api  # run backend wt-rest-api in debug mode
    spindown  # spin down the services, make it publicly unavailable
    spinup    # spin up the services, make it publicly available
    websocket # run backend wt-websocket in debug mode
```

## Roadmap to Production

> Frontend or backend features are not included in this section.

High availability:

- the service should be deployed in a k8s cluster by CI/CD.
- a helm chart should be written to be used in deployment process.
- the database should be running on the Cloud (e.g. AWS RDS), managed by DBA.

Infrastructure as code:

- trigger opentofu only in CI/CD (not locally by typing commands).

Release process:

- proper version management of application and OAS is mandatory.
- test and release process may be something like: dev, stage, production.\
  (probably with blue/green tests according the naturally split user group).

Observability:

- observability integrated into code (e.g. OpenTelemetry).
- observability deploy in the k8s cluster (e.g. Prometheus, Grafana).
